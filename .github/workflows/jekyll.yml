name: Deploy Jekyll site with Data Processing

on:
  push:
    branches:
      - main
      - omeka-import
  workflow_dispatch:

permissions:
  contents: read
  pages: write
  id-token: write

concurrency:
  group: "pages"
  cancel-in-progress: false

env:
  OMEKA_API_URL: ${{ secrets.OMEKA_API_URL }}
  KEY_IDENTITY: ${{ secrets.KEY_IDENTITY }}
  KEY_CREDENTIAL: ${{ secrets.KEY_CREDENTIAL }}
  ITEM_SET_ID: ${{ secrets.ITEM_SET_ID }}

jobs:
  data-processing:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      - uses: actions/setup-python@v5
        with:
          python-version: '3.12'
      - run: pip install pandas requests
      - name: Process Data
        run: |
          import os
          import pandas as pd
          import requests
          from urllib.parse import urlparse, parse_qs

          OMEKA_API_URL = os.environ.get("OMEKA_API_URL")
          KEY_IDENTITY = os.environ.get("KEY_IDENTITY")
          KEY_CREDENTIAL = os.environ.get("KEY_CREDENTIAL")
          ITEM_SET_ID = os.environ.get("ITEM_SET_ID")      
        
          def get_media(item_id):
              url = OMEKA_API_URL + "media/" + str(item_id)
              params = {"key_identity": KEY_IDENTITY, "key_credential": KEY_CREDENTIAL}
              response = requests.get(url, params=params)
              if response.status_code != 200:
                  print(f"Error: {response.status_code}")
                  return None
              return response.json()
          
          def map_columns(item_set):
              return_list = []
              for data in item_set:
                  media_list = data.get("o:media", [])
                  if len(media_list) > 1:
                      media = get_media(media_list[0]["o:id"]) if media_list else {}
                      media_data = create_media_data_dict(data, media, "compound_object")
                      return_list.append(media_data)
                      for index, media_item in enumerate(media_list):
                          media = get_media(media_item.get("o:id"))
                          media_data = create_media_data_dict(data, media, "compound_object", index)
                          return_list.append(media_data)
                  else:
                      media = get_media(media_list[0]["o:id"]) if media_list else {}
                      media_data = create_media_data_dict(data, media)
                      return_list.append(media_data)
              return return_list
          
          def create_media_data_dict(data, media, type=None, index=None):
              media_id_suffix = f"_{index}" if index is not None else ""
              media_url = media.get("thumbnail_display_urls", {}).get("large") if media and media.get("thumbnail_display_urls", {}).get("large", "").startswith("http") else None
          
              return {
                  "objectid": data.get("dcterms:identifier", [{}])[0].get("@value").lower() + media_id_suffix,
                  "parentid": None if index is None else data.get("dcterms:identifier", [{}])[0].get("@value").lower(),
                  "title": data.get("dcterms:title", [{}])[0].get("@value"),
                  "creator": data.get("dcterms:creator", [{}])[0].get("@value"),
                  "date": data.get("dcterms:date", [{}])[0].get("@value"),
                  "era": data.get("dcterms:temporal", [{}])[0].get("@value"),
                  "description": data.get("dcterms:description", [{}])[0].get("@value"),
                  "subject": "; ".join([item.get("@value", "") for item in data.get("dcterms:subject", [])]),
                  "publisher": data.get("dcterms:publisher", [{}])[0].get("@value"),
                  "source": data.get("dcterms:source", [{}])[0].get("@value"),
                  "relation": data.get("dcterms:relation", [{}])[0].get("@value"),
                  "hasVersion": data.get("dcterms:hasVersion", [{}])[0].get("@value"),
                  "type": data.get("dcterms:type", [{}])[0].get("@id"),
                  "format": data.get("dcterms:format", [{}])[0].get("@value"),
                  "extent": data.get("dcterms:extent", [{}])[0].get("@value"),
                  "language": data.get("dcterms:language", [{}])[0].get("o:label"),
                  "rights": "; ".join([item.get("@value", "") for item in data.get("dcterms:rights", [])]),
                  "license": data.get("dcterms:license", [{}])[0].get("@value"),
                  "isPartOf": data.get("dcterms:isPartOf", [{}])[0].get("@value"),
                  "isReferencedBy": data.get("dcterms:isReferencedBy", [{}])[0].get("@value"),
                  "display_template": type,
                  "object_location": None,
                  "image_small": media_url,
                  "image_thumb": media_url,
                  "image_alt_text": None,
                  "object_transcript": None,
              }
          
          item_set = get_items_from_collection(ITEM_SET_ID)
          item_set_mapped = map_columns(item_set)
          item_set_mapped_df = pd.DataFrame(item_set_mapped)
          item_set_mapped_df.to_csv("_data/sgb-metadata.csv", index=False)
        shell: python
      - name: Upload artifact
        uses: actions/upload-artifact@v3
        with:
          name: sgb-metadata
          path: _data/sgb-metadata.csv

  build:
    needs: data-processing
    runs-on: ubuntu-latest
    steps:
      - name: Checkout
        uses: actions/checkout@v4
      - name: Download artifact
        uses: actions/download-artifact@v3
        with:
          name: sgb-metadata
          path: _data
      - name: Setup Ruby
        uses: ruby/setup-ruby@8575951200e472d5f2d95c625da0c7bec8217c42 # v1.161.0
        with:
          bundler-cache: true
          cache-version: 0
      - name: Setup Pages
        id: pages
        uses: actions/configure-pages@v4
      - name: Build with Jekyll
        run: bundle exec jekyll build --baseurl "${{ steps.pages.outputs.base_path }}"
        env:
          JEKYLL_ENV: production
      - name: Upload artifact
        uses: actions/upload-pages-artifact@v3

  deploy:
    needs: build
    runs-on: ubuntu-latest
    steps:
      - name: Deploy to GitHub Pages
        id: deployment
        uses: actions/deploy-pages@v4
    environment:
      name: github-pages
      url: ${{ steps.deployment.outputs.page_url }}
